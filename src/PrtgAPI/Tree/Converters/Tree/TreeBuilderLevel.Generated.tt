<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="../../../Request/T4Functions.ttinc" #>
<#@ output extension=".cs" #>
/******************************************************************************************
 * This code was generated by a tool.                                                     *
 * Please do not modify this file directly - modify TreeBuilderLevel.Generated.tt instead *
 ******************************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using PrtgAPI.Tree.Internal;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI.Tree.Converters.Tree
{
    internal partial class TreeBuilderLevel
    {
        //######################################
        // GetDeviceChildren
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("GetDeviceChildren", "List<PrtgOrphan>", i) #>(IDevice device)
        {
            if (device.TotalSensors > 0 && Options.Contains(TreeParseOption.Sensors))
            {
                Token.ThrowIfCancellationRequested();

                var sensors = <#= CallFunction("GetOrphans", "ObjectManager.Sensor", i) #>;

                return sensors;
            }

            return new List<PrtgOrphan>();
        }

<#
}
#>
        //######################################
        // GetContainerChildren
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("GetContainerChildren", "List<PrtgOrphan>", i) #>(IGroupOrProbe parent)
        {
            List<ObjectFactory> factories = new List<ObjectFactory>();

            if (parent.Id == WellKnownId.Root && Options.Contains(TreeParseOption.Probes))
                factories.Add(ObjectManager.Probe);
            else
            {
                if (parent.TotalDevices > 0 && Options.Contains(TreeParseOption.Devices))
                    factories.Add(ObjectManager.Device);

                if (parent.TotalGroups > 0 && Options.Contains(TreeParseOption.Groups))
                    factories.Add(ObjectManager.Group);
            }

            var results = <#= CallFunction("GetOrphans", "factories.ToArray()", i) #>;

            return results;
        }

<#
}
#>
        //######################################
        // GetTriggers
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("GetTriggers", "TriggerOrphanCollection", i) #>()
        {
            var obj = Value as SensorOrDeviceOrGroupOrProbe;

            if (obj != null && obj.NotificationTypes.TotalTriggers > 0 && Options.Contains(TreeParseOption.Triggers))
            {
                Token.ThrowIfCancellationRequested();

                var triggers = <#= CallFunctionWithAsyncOnlyToken("ObjectManager.Trigger.Objects", "Value.Id.Value", "Token", i) #>;

                if (triggers.Count == 0)
                    return null;

                var orphans = triggers.Select(t => ObjectManager.Trigger.Orphan(t, null)).Cast<TriggerOrphan>();

                return PrtgOrphan.TriggerCollection(orphans);
            }

            return null;
        }

<#
}
#>
        //######################################
        // GetProperties
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("GetProperties", "PropertyOrphanCollection", i) #>()
        {
            var obj = Value as SensorOrDeviceOrGroupOrProbe;

            if (obj != null && Options.Contains(TreeParseOption.Properties))
            {
                Token.ThrowIfCancellationRequested();

                var properties = <#= CallFunctionWithAsyncOnlyToken("ObjectManager.Property.Objects", "obj.Id", "Token", i) #>;
                var orphans = properties.Select(p => ObjectManager.Property.Orphan(p, null)).Cast<PropertyOrphan>();

                return PrtgOrphan.PropertyCollection(orphans);
            }

            return null;
        }

<#
}
#>
        //######################################
        // GetOrphans
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        /// <summary>
        /// Retrieves <see cref="ITreeValue"/> values objects from a set of object factories, retrieves the children
        /// of each object from the next <see cref="TreeBuilderLevel"/> and encapsulates the object and its children in a <see cref="PrtgOrphan"/>.
        /// </summary>
        /// <param name="factories">The factories to retrieve objects from.</param>
        /// <returns>A list of <see cref="PrtgOrphan"/> objects encapsulating the values returnd from the factories and their respective children.</returns>
        private <#= GetSignature("GetOrphans", "List<PrtgOrphan>", i) #>(params ObjectFactory[] factories)
        {
            List<Tuple<ITreeValue, ObjectFactory>> results = new List<Tuple<ITreeValue, ObjectFactory>>();

            foreach (var factory in factories)
            {
                Token.ThrowIfCancellationRequested();

                var objs = <#= CallFunctionWithAsyncOnlyToken("factory.Objects", "Value.Id.Value", "Token", i) #>;

                results.AddRange(objs.Select(o => Tuple.Create(o, factory)));
            }

            ProgressManager.OnLevelWidthKnown(Value, ValueType, results.Count);

            var orphans = new List<PrtgOrphan>();

            foreach (var item in results)
            {
                ProgressManager.OnProcessValue(item.Item1);

                var level = new TreeBuilderLevel(item.Item1, item.Item2.Type, item.Item2.Orphan, builder);

                orphans.Add(<#= CallFunction("level.ProcessObject", null, i) #>);
            }

            return orphans;
        }
<#
if (i == 0)
    WriteLine("");
}
#>
    }
}
